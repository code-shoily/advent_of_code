defmodule AdventOfCode.Helpers.Summarizer do
  @moduledoc """
  Collects summary information about the codebase such as number of stars, problems solved etc
  """

  alias AdventOfCode.Helpers.Meta

  @year_range 2015..AdventOfCode.get_latest_year()//1
  @total_problems Range.size(@year_range) * 25
  @total_stars @total_problems * 2

  @doc """
  Generates the latter (autogenerated + tabular) part README.md page.
  """
  def summarize do
    metadata = Map.new(@year_range, &{&1, Meta.get_info(&1, true)})

    stars_completed =
      Enum.map(metadata, fn {_, %{completed: completed}} -> completed end) |> Enum.sum()

    problems_solved = stars_completed / 2

    year_links = Enum.map_join(@year_range, "|", fn year -> " [#{year}](/lib/#{year}) " end)
    header = "| Day |#{year_links}|"
    stars = ":star: #{stars_completed}/#{@total_stars} :dart: #{@total_stars - stars_completed}"
    problems = ":trophy: #{problems_solved}/#{@total_problems} :dart: #{@total_problems - problems_solved}"
    score_summary = "# #{stars} #{problems}"
    content = for i <- 0..25, do: generate_stat_row(metadata, i)
    aligner_years = Enum.map_join(@year_range, "|", fn _ -> ":-:" end)

    """
    #{stars}

    #{score_summary}

    #{header}
    |:---:|#{aligner_years}|
    #{content}
    """
  end

  defp generate_stat_row(metadata, 0) do
    stars =
      for year <- @year_range do
        metadata[year].completed
      end
      |> Enum.join(" | ")

    """
    | :star2: | #{stars} |
    """
  end

  defp generate_stat_row(metadata, day) do
    counts =
      for year <- @year_range do
        case metadata[year].summary[day] do
          nil -> " "
          %{count: count} -> award(count)
        end
      end
      |> Enum.join(" | ")

    """
    | #{day} | #{counts} |
    """
  end

  defp build_heading(year) do
    links =
      for current_year <- @year_range do
        if current_year == year do
          to_string(current_year)
        else
          "[#{current_year}](/lib/#{current_year})"
        end
      end

    """
    <!-- AUTOGENERATED -- DO NOT EDIT -- use `mix gen_stats` -->
    # Advent of Code #{year}

    [Main Page](https://adventofcode.com/#{year}) | [Tests](/test/#{year})

    #{links |> Enum.join(" | ")}
    """
  end

  @doc """
  Generates yearwise README page content (in markdown format)
  """
  def yearwise_readme(year) do
    heading = build_heading(year)
    info = Meta.get_info(year)
    trophy = "## :trophy: #{info.completed}/50"

    {table_header, aligner, table_content} = summary_table(info.summary)

    """
    #{heading}

    #{trophy}

    #{table_header}
    #{aligner}
    #{table_content}
    """
  end

  @doc """
  Generates page containing all the tags.
  """
  def tag_page do
    generate_subpage(
      "Tags",
      "List of all tags to categorize solutions.",
      :tag_summary,
      fn {k, _} -> k end
    )
  end

  @doc """
  Generates page containing all difficulty levels.
  """
  def difficulty_page do
    generate_subpage(
      "Difficulties",
      "List of (relative) difficulties encountered while solving.",
      :difficulty_summary,
      fn {k, _} -> difficulty_level(k) end
    )
  end

  defp generate_subpage(title, description, attr, sorter) do
    metadata =
      Meta.solutions_summary()
      |> Map.values()
      |> Enum.map(& &1[attr])
      |> Enum.reduce(%{}, fn x, acc ->
        Map.merge(acc, x, fn _, v1, v2 -> v1 ++ v2 end)
      end)
      |> Enum.sort_by(sorter)

    content =
      metadata
      |> Enum.map(fn {head, summary} ->
        {table_header, aligner, table_content} = summary_table(summary, true)

        """
        ## #{head}

        #{table_header}
        #{aligner}
        #{table_content}
        """
      end)

    """
    # #{title}

    # #{description}

    ### Please Note:
    * The statistics on this page is not as refined as I would like it to be, will revisit problems,
    optimize them and update this page with refined and more accurate data.
    * Instead of a single page, I am planning to add a per tag or per difficulty page for less overwhelming content.

    #{content}
    """
  end

  defp summary_table(summary, show_year \\ false) do
    table_header =
      "| Day | Problem Page | Status | Difficulty | Solution Page | Test Page | Tags |"

    table_content =
      for {day,
           %{
             title: title,
             link: link,
             count: count,
             difficulty: difficulty,
             solution: solution,
             test: test,
             tags: tags,
             year: year
           }} <- summary do
        day = (show_year && "#{year}/#{day}") || day

        """
        | #{day} | [#{title}](#{link}) | #{award(count)} | #{difficulty(difficulty)} | #{linkify(solution)} | #{linkify(test)} | #{tags(tags)} |
        """
      end

    aligner = "| :---: | :------: | :---: | :---: | :---: | :---: | :---: |"

    {table_header, aligner, table_content}
  end

  @difficulty_sizes ~w/xs s m l xl xxl/
  defp difficulty_level("xs"), do: 1
  defp difficulty_level("s"), do: 2
  defp difficulty_level("m"), do: 3
  defp difficulty_level("l"), do: 4
  defp difficulty_level("xl"), do: 5
  defp difficulty_level("xxl"), do: 6
  defp difficulty_level(_), do: 7

  defp difficulty_icon(count), do: ":snowflake:" |> List.duplicate(count) |> Enum.join(" ")

  defp difficulty(size) when size in @difficulty_sizes,
    do: size |> difficulty_level() |> difficulty_icon()

  defp difficulty(_), do: ":shrug:"

  defp tags(tags), do: tags |> Enum.map_join(", ", fn tag -> "[#{tag}](/tags.md##{tag})" end)

  defp award(1), do: ":2nd_place_medal:"
  defp award(2), do: ":1st_place_medal:"

  defp linkify(link) do
    file = link |> String.split("/") |> List.last()
    "[#{file}](#{link})"
  end
end
